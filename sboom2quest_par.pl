#!/usr/bin/env perl

# $Id: sboom2quest.pl,v 1.2 2021/05/10 22:49:28 mnemec Exp $

# parses loud.dat and output.out files generated by sBOOM and formats them into
# QUEST xml data format for UQ analysis

# MN, NASA ARC, April 2020

use strict;
use warnings;
use English qw{ -no_match_vars };
use FileHandle;
use File::Basename;
use File::Spec;
use File::Find;
use Getopt::Long;
use Cwd;
use XML::LibXML;

local $PROGRAM_NAME = basename($PROGRAM_NAME);

my $verbose;
my $sec;
my $help;
my $cmdline = $PROGRAM_NAME;

my $loudnessdir = 'QUEST_loudness';
my $loud        = 'loud.dat';
my $out         = 'output.out';

if (@ARGV) {
  foreach (@ARGV) {
    $cmdline .= /\s/ ? " \'" . $_ . "\'" : " " . $_;
  }
  GetOptions(
    'v'     => \$verbose,
    'p=s'   => \$sec,
    'h'     => \$help,
    'help'  => \$help,
    ""      => \$help
  );
}
die "Usage: $PROGRAM_NAME [-v]
Parses loud.dat and output.out files to generate QUEST xml data files
    -v      verbose mode\n
    -p      p0000th index to run\n"
    if ($help);

my $dbdir;
if ( -d 'cases' ) {
  $dbdir = 'cases';
}
else {
  exit 0;
}

my @caseDirs;
opendir(my $dh, $dbdir) || die "Can't open directory: $!";
while (readdir $dh) {
  my $dir = File::Spec->catdir($dbdir, $_); 
  next unless (-d $dir);
  next unless ( $dir =~ /case\.$sec\d+/ );
  push @caseDirs, $dir;
}
closedir $dh;

exit 0 unless (@caseDirs);

mkdir $loudnessdir;

my @outdata; # for output of all data in simple column format
my $datfile = 'loudness.dat';
my $header;
my $first = 1;
my $root_dir = cwd;

foreach my $dir (sort {$a cmp $b} @caseDirs) {

  print "# Processing $dir\n" if $verbose;

  my @scratch   = split '\.', $dir;
  my $questfile = 'loudness.00000.' . $scratch[1] . '.' . $scratch[2] . '.xml'; 

  my $dirID = $scratch[1] . $scratch[2];

  chdir $dir;

  my %carpet;
  my @loudFiles;

  find sub { push @loudFiles, $File::Find::name, 
             if (-f and /^${loud}/ and ( $File::Find::dir =~ /sboom/ ) ) },
  File::Spec->curdir();

  foreach my $f (@loudFiles) {

    my $fh = FileHandle->new( "$f", '<' );
    die "ERROR: Cannot read $f, stopped " unless ( defined $fh );

    my %loud;
    my $angle;
    my $mach;

    while (<$fh>) {
      next if /^#/;      # skip comments
      next unless /\w/;  # skip empty lines
      chomp;

      (my @scratch) = split ' ', $_;

      if ( /^Loudness\ values\ at/ ) {
        $scratch[6] =~ s/,//;
        $angle = $scratch[6];
        $mach  = $scratch[$#scratch];
        $loud{'Mach'} = $mach;
      }
      elsif ( /^Objective\ Function\ Value/ ) {
        my $label = $scratch[0];
        my $value = $scratch[4];
        $loud{$label} = $value;
      }
      else {
        my $label = $scratch[0];
        my $value = $scratch[2];
        $loud{$label} = $value;
      }
    }
    undef $fh;

    my $path = dirname($f);

    my $output = File::Spec->catpath('', $path, $out);

    if ( -e $output ) {
      my $proptime       = 0;
      my $negative_side  = 0;
      my $neg_side_angle = 0;
      my $positive_side  = 0;
      my $pos_side_angle = 0;

      $fh = FileHandle->new( "$output", '<' );
      die "ERROR: Cannot read $output, stopped " unless ( defined $fh );

      while (<$fh>) {
        next if /^#/;      # skip comments
        next unless /\w/;  # skip empty lines
        chomp;
        if ( /^Propagation\ time/ ) {
          ( my @scratch ) = split ' ', $_;
          $proptime = $scratch[2];
        }
        elsif ( /^CARPET\ WIDTH\ on\ negative\ side/ ) {
          ( my @scratch ) = split ' ', $_;
          $negative_side  = $scratch[6]*0.0003048;
          $neg_side_angle = $scratch[13];
        }
        elsif ( /^CARPET\ WIDTH\ on\ positive\ side/ ) {
          ( my @scratch ) = split ' ', $_;
          $positive_side  = $scratch[6]*0.0003048;
          $pos_side_angle = $scratch[13];
        }
      }
      undef $fh;

      $loud{'Propagation Time (s)'} = $proptime;

      my $d = abs($negative_side) + abs($positive_side);
      $loud{'Negative Side (km)'}         = $negative_side;
      $loud{'Positive Side (km)'}         = $positive_side;
      $loud{'Carpet Width (km)'}          = $d;
      $loud{'Negative Side Angle (deg.)'} = $neg_side_angle;
      $loud{'Positive Side Angle (deg.)'} = $pos_side_angle;
    }

    my $presb = File::Spec->catpath('', $path, 'presb.input');
    if ( -e $presb ) {
      my $altitude = 0;
      my $ref_fac  = 0;
      my $ground   = 0;

      $fh = FileHandle->new( "$presb", '<' );
      die "ERROR: Cannot read $presb, stopped " unless ( defined $fh );

      while (<$fh>) {
        next if /^#/;      # skip comments
        next unless /\w/;  # skip empty lines
        chomp;
        if ( /Cruise\ Altitude\ / ) {
          ( my @scratch ) = split ' ', $_;
          $altitude = $scratch[0];
        }
        elsif (/Reflection\ factor\ at\ ground\ level/ ) {
          ( my @scratch ) = split ' ', $_;
          $ref_fac = $scratch[0];
        }
        elsif (/Height\ of\ the\ ground\ in\ feet/ ) {
          ( my @scratch ) = split ' ', $_;
          $ground = $scratch[0];
        }
      }
      undef $fh;

      $loud{'Altitude (ft)'}      = $altitude;
      $loud{'Reflection Factor'}  = $ref_fac;
      $loud{'Ground Height (ft)'} = $ground;
    }

    $carpet{$angle} = \%loud;
  }

  chdir $root_dir;

  # numerically sort off-track angles
  my @angles;
  @angles = sort { $a <=> $b } keys %carpet;
  if ( ! @angles ) {
    print "no carpet angles\n";
    exit 1;
  }

  my @names;
  foreach my $key ( sort { $a <=> $b } keys %carpet ) {
    my $href = $carpet{$key};
    my %hash = %$href;
    @names = sort keys %hash;
  }
  if ( ! @names ) {
    print "no loudness values\n";
    exit 1;
  }

  my @output_names;
  foreach ( @names ) {
    next if ( /Altitude/ or /Mach/ or /Ground\ / or /Reflection\ / );
    push @output_names, $_;
  }

  # output QUEST xml data file
  my $doc = XML::LibXML::Document->createDocument( "1.0", "ISO-8859-1" );

  my $element = $doc->createElement('root');
  $doc->setDocumentElement($element);

  my $child = $doc->createElement("LoudnessData");
  $element = $element->addChild($child);

  $child = $doc->createElement("data");
  $element = $element->addChild($child);

  my $nscalars = 1;
  $child = $doc->createElement("abscissas");
  $child->appendText("${nscalars}");
  $element->addChild($child);

  foreach (1...$nscalars) {
    my $i = $_ -1;
    $child = $doc->createElement("abscissa${i}_name");
    $child->appendText("Off-Track Angle (deg.)");
    $element->addChild($child);
  }

  $nscalars = scalar @output_names;
  
  $child = $doc->createElement("ordinates");
  $child->appendText("${nscalars}");
  $element->addChild($child);

  my $i = 0;
  foreach my $label (@output_names) {
    $child = $doc->createElement("ordinate${i}_name");
    $child->appendText("$label");
    $element->addChild($child);
    $child = $doc->createElement("ordinate${i}_type");
    $child->appendText("0");
    $element->addChild($child);
    $i++;
  }

  $i = 0;
  my $angle = shift @angles;
  $child = $doc->createElement("index");
  $child->appendText("$i");
  $element->addChild($child);
  $child = $doc->createElement("abscissa0_val");
  $child->appendText("$angle");
  $element->addChild($child);
  $i++;

  my @hold; # temp array to hold output data
  push @hold, $angle;
  $header = '# 1.Angle' if $first;

  my $j = 0;
  my $href = $carpet{$angle};
  my %hash = %$href;
  foreach my $label (@output_names) {
    $child = $doc->createElement("ordinate${j}_val");
    my $value = $hash{$label};
    $child->appendText("$value");
    $element->addChild($child);
    $j++;
  }

  # keep track of all inputs and outputs, these will be written to loudness.dat
  my $k = 2;
  foreach my $label (@names) {
    my $value = $hash{$label};
    push @hold, $value;
    my $label_ws = $label;
    $label_ws =~ s/\ /_/g;
    $header .= " ${k}.${label_ws} " if $first;
    $k++;
  }
  push @hold, $dirID;
  $header .= " ${k}.CaseDir\n" if $first;
  $first = 0;

  push @outdata, \@hold; # save data in global array

  $element = $element->parentNode;

  foreach my $angle (@angles) {
    $child = $doc->createElement("data");
    $element = $element->addChild($child);
    $child = $doc->createElement("index");
    $child->appendText("$i");
    $element->addChild($child);
    $child = $doc->createElement("abscissa0_val");
    $child->appendText("$angle");
    $element->addChild($child);
    
    my @hold;
    push @hold, $angle;

    my $j = 0;
    my $href = $carpet{$angle};
    my %hash = %$href;
    foreach my $label (@output_names) {
      $child = $doc->createElement("ordinate${j}_val");
      my $value = $hash{$label};
      $child->appendText("$value");
      $element->addChild($child);
      $j++;
    }

    # keep track of all inputs and outputs, these will be written to loudness.dat
    foreach my $label (@names) {
      my $value = $hash{$label};
      push @hold, $value;
    }

    push @outdata, \@hold; # save data in global array
    $element = $element->parentNode;
    $i++;
  }

  my $doc_string = $doc->toString(2); # pretty format
  $doc_string =~ s/>\n\s*\n/>\n/g;    # remove excessive new-line sequences

  undef $doc;

  my $fh = FileHandle->new( "${loudnessdir}/${questfile}", '>' );
  print $fh $doc_string;
  undef $fh;
}

my $fh = FileHandle->new( "${loudnessdir}/${datfile}", '>' );

print $fh "# All input and output data\n";
print $fh $header;
foreach my $data (@outdata) {
  foreach my $item (@$data) {
    print $fh "$item ";
  }
  print $fh "\n";
}
undef $fh;

print "# Wrote QUEST xml data and summary $datfile in $loudnessdir\n" if $verbose;

exit 0;
